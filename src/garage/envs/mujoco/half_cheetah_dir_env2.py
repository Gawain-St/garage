"""Variant of the HalfCheetahEnv with different target directions."""
from gym.envs.mujoco import HalfCheetahEnv as HalfCheetahEnv_

try:
    from garage import EnvSpec
except ImportError:
    from garage.envs import EnvSpec
import numpy as np

class HalfCheetahEnvMetaBase(HalfCheetahEnv_):
    """Base class of HalfCheetah meta-environments.

    Code is adapted from
    https://github.com/tristandeleu/pytorch-maml-rl/blob/493e677e724aa67a531250b0e215c8dbc9a7364a/maml_rl/envs/mujoco/half_cheetah.py

    Which was in turn adapted from
    https://github.com/cbfinn/maml_rl/blob/9c8e2ebd741cb0c7b8bf2d040c4caeeb8e06cc95/rllab/envs/mujoco/half_cheetah_env_rand.py

    Args:
        task (dict): Subclass specific task information.

    """

    def __init__(self, task):
        self._task = task
        super().__init__()
        self.spec = EnvSpec(action_space=self.action_space,
                            observation_space=self.observation_space)

    def _get_obs(self):
        """Get a low-dimensional observation of the state.

        Returns:
            np.ndarray: Contains the flattened angle quaternion, angular
                velocity quaternion, and cartesian position.

        """
        return np.concatenate([
            self.sim.data.qpos.flat[1:],
            self.sim.data.qvel.flat,
            self.get_body_com('torso').flat,
        ]).astype(np.float32).flatten()

    def viewer_setup(self):
        """Start the viewer."""
        camera_id = self.model.camera_name2id('track')
        self.viewer.cam.type = 2
        self.viewer.cam.fixedcamid = camera_id
        self.viewer.cam.distance = self.model.stat.extent * 0.35
        # Hide the overlay
        # This code was inheritted, so we'll ignore this access violation for
        # now.
        # pylint: disable=protected-access
        self.viewer._hide_overlay = True

    def __getstate__(self):
        """See `Object.__getstate__.

        Returns:
            dict: The instanceâ€™s dictionary to be pickled.

        """
        return dict(task=self._task)

    def __setstate__(self, state):
        """See `Object.__setstate__.

        Args:
            state (dict): Unpickled state of this object.

        """
        self.__init__(task=state['task'])

class HalfCheetahDirEnv(HalfCheetahEnvMetaBase):
    """Half-cheetah environment with target direction, as described in [1].

    The code is adapted from
    https://github.com/cbfinn/maml_rl/blob/9c8e2ebd741cb0c7b8bf2d040c4caeeb8e06cc95/rllab/envs/mujoco/half_cheetah_env_rand_direc.py

    The half-cheetah follows the dynamics from MuJoCo [2], and receives at each
    time step a reward composed of a control cost and a reward equal to its
    velocity in the target direction. The tasks are generated by sampling the
    target directions from a Bernoulli distribution on {-1, 1} with parameter
    0.5 (-1: backward, +1: forward).

    [1] Chelsea Finn, Pieter Abbeel, Sergey Levine, "Model-Agnostic
        Meta-Learning for Fast Adaptation of Deep Networks", 2017
        (https://arxiv.org/abs/1703.03400)
    [2] Emanuel Todorov, Tom Erez, Yuval Tassa, "MuJoCo: A physics engine for
        model-based control", 2012
        (https://homes.cs.washington.edu/~todorov/papers/TodorovIROS12.pdf)

    Args:
        task (dict or None):
            direction (float): Target direction, either -1 or 1.

    """

    def __init__(self, task=None):
        super().__init__(task or {'direction': 1.})

    def step(self, action):
        """Take one step in the environment.

        Equivalent to step in HalfCheetahEnv, but with different rewards.

        Args:
            action (np.ndarray): The action to take in the environment.

        Raises:
            ValueError: If the current direction is not 1.0 or -1.0.

        Returns:
            tuple:
                * observation (np.ndarray): The observation of the environment.
                * reward (float): The reward acquired at this time step.
                * done (boolean): Whether the environment was completed at this
                    time step. Always False for this environment.
                * infos (dict):
                    * reward_forward (float): Reward for moving, ignoring the
                        control cost.
                    * reward_ctrl (float): The reward for acting i.e. the
                        control cost (always negative).
                    * task_dir (float): Target direction. 1.0 for forwards,
                        -1.0 for backwards.

        """
        xposbefore = self.sim.data.qpos[0]
        self.do_simulation(action, self.frame_skip)
        xposafter = self.sim.data.qpos[0]

        forward_vel = (xposafter - xposbefore) / self.dt
        forward_reward = self._task['direction'] * forward_vel
        ctrl_cost = 0.5 * 1e-1 * np.sum(np.square(action))

        observation = self._get_obs()
        reward = forward_reward - ctrl_cost
        done = False
        if self._task['direction'] == 1.:
            task_name = 'forward'
        elif self._task['direction'] == -1.:
            task_name = 'backward'
        else:
            raise ValueError('task direction should be 1. or -1.')
        infos = dict(reward_forward=np.asarray([forward_reward]),
                     reward_ctrl=np.asarray([-ctrl_cost]),
                     task_dir=np.asarray([self._task['direction']]),
                     task_name=task_name)
        return observation, reward, done, infos

    def sample_tasks(self, num_tasks):
        """Sample a list of `num_tasks` tasks.

        Args:
            num_tasks (int): Number of tasks to sample.

        Returns:
            list[dict[str, float]]: A list of "tasks," where each task is a
                dictionary containing a single key, "direction", mapping to -1
                or 1.

        """
        directions = (
            2 * self.np_random.binomial(1, p=0.5, size=(num_tasks, )) - 1)
        tasks = [{'direction': direction} for direction in directions]
        return tasks

    def set_task(self, task):
        """Reset with a task.

        Args:
            task (dict[str, float]): A task (a dictionary containing a single
                key, "direction", mapping to -1 or 1).

        """
        self._task = task
